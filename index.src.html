<h1>Content Security Policy Level 3</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec-csp/
TR: http://www.w3.org/TR/CSP3/
Shortname: CSP
Level: 3
Editor: Mike West 56384, Google Inc., mkwst@google.com
Group: webappsec
Abstract:
  This document defines a mechanism by which web developers can control the
  resources which a particular page can fetch or execute, as well as a number
  of security-relevant policy decisions.
Indent: 2
Version History: https://github.com/w3c/webappsec-csp/commits/master/index.src.html
Boilerplate: omit conformance, omit feedback-header
!Participate: <a href="https://github.com/w3c/webappsec-csp/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-csp/issues">open issues</a>)
Markup Shorthands: css off, markdown on
</pre>
<pre class="anchors">
spec: ES2015; urlPrefix: http://www.ecma-international.org/ecma-262/6.0/index.html
  type: method
    text: eval(); url: sec-eval-x
spec: DOM; urlPrefix: http://www.w3.org/TR/dom/
  type: interface
    text: Node; url: interface-node
  type: attribute
    text: textContent; for: Node; url: dom-node-textcontent
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: main fetch
    text: http-network fetch
    text: http fetch
    text: parse a header value; url: concept-header-parse
    text: request; url: concept-request
    text: response; url: concept-response
    text: header; url: concept-header
    text: client; for: request; url: concept-request-client
    text: url; for: request; url: concept-request-url
    text: url; for: response; url: concept-response-url
    text: header list; for: response; url: concept-response-header-list
    text: name; for: header; url: concept-header-name
    text: network error; url: concept-network-error
    text: destination; for: request; url: concept-request-destination
    text: type; for: request; url: concept-request-type
    text: initiator; for: request; url: concept-request-initiator
    text: target browsing context; for: request; url: concept-request-target-browsing-context
  type: interface
    text: Request
spec: HTML5; urlPrefix: http://www.w3.org/TR/html5/
  type: dfn
    urlPrefix: embedded-content-0.html
      text: an iframe srcdoc document
    urlPrefix: browsers.html
      text: active document
      text: ancestor browsing context
      text: browsing context
      text: create a document object
      text: creator document
      text: nested browsing context
      text: nested through; url: browsing-context-nested-through
    urlPrefix: webappapis.html
      text: environment settings object; url: settings-object
      text: global object
      text: incumbent settings object
      text: relevant settings object; url: relevant-settings-object-for-a-global-object
      text: responsible browsing context
    urlPrefix: infrastructure.html
      text: case-sensitive; url: case-sensitive
      text: ASCII case-insensitive match; url: ascii-case-insensitive
      text: reflect
      text: strictly split a string
      text: strip leading and trailing whitespace
      text: collect a sequence of characters
      text: space characters
      text: split a string on spaces
      text: split a string on commas
    urlPrefix: document-metadata.html
      text: pragma directives
      text: set the frozen base url
    urlPrefix: scripting-1.html
      text: prepare a script
      text: the script block's source; url: the-script-block's-source
  type: element
    urlPrefix: document-metadata.html
      text: base; url: the-base-element
      text: head; url: the-head-element
      text: link; url: the-link-element
      text: meta; url: the-meta-element
      text: style; url: the-style-element
    urlPrefix: embedded-content-0.html
      text: embed; url: the-embed-element
      text: object; url: the-object-element
      text: iframe; url: the-iframe-element
    urlPrefix: scripting-1.html
      text: script; url: the-script-element
    urlPrefix: text-level-semantics.html
      text: a; url: the-a-element
    urlPrefix: obsolete.html
      text: applet; url: the-applet-element
      text: frame
  type: element-attr
    urlPrefix: document-metadata.html
      text: content; for: meta; url: attr-meta-content
      text: http-equiv; for: meta; url: attr-meta-http-equiv
    urlPrefix: embedded-content-0.html
      text: srcdoc; for: iframe; url: attr-iframe-srcdoc
    urlPrefix: scripting-1.html
      text: src; for: script; url: attr-script-src
  type: interface
    urlPrefix: dom.html
      text: Document
    urlPrefix: browsers.html
      text: Window; url: dom-window
  type: attribute
    urlPrefix: browsers.html
      text: document; for: Window; url: dom-document-2
spec: URL; urlPrefix: https://url.spec.whatwg.org/
  type: dfn
    text: local scheme
    text: default port
    text: IPv6 address; url: concept-ipv6
    text: percent decode
  type: attribute
    text: host; for: URL; url: concept-url-host
    text: port; for: URL; url: concept-url-port
    text: path; for: URL; url: concept-url-path
    text: origin; for: URL; url: concept-url-origin
    text: scheme; for: URL; url: concept-url-scheme
  type: interface;
    text: URL
spec: SERVICE-WORKERS; urlPrefix: http://www.w3.org/TR/service-workers/
  type: interface
    text: ServiceWorker; url: service-worker-interface
spec: WORKERS; urlPrefix: http://www.w3.org/TR/workers/
  type: interface
    text: Worker
spec: RFC3986; urlPrefix: https://tools.ietf.org/html/rfc3986
  type: grammar
    text: path; url: section-3.3
    text: scheme; url: section-3.1
    text: IPv4address; url: section-3.2.2
spec: RFC4648; urlPrefix: https://tools.ietf.org/html/rfc4648
  type: dfn
    text: base64 encoding; url: section-4
spec: RFC5234; urlPrefix: https://tools.ietf.org/html/rfc5234
  type: grammar
    text: ALPHA; url: appendix-B.1
    text: DIGIT; url: appendix-B.1
    text: VCHAR; url: appendix-B.1
    text: WSP; url: appendix-B.1
spec: RFC5890; urlPrefix: https://tools.ietf.org/html/rfc5890
  type: dfn
    text: label; url: section-2.2
spec: RFC6454; urlPrefix: https://tools.ietf.org/html/rfc6454
  type: dfn
    text: globally unique identifier; url: section-2.3
    text: origin; url: section-3.2
    text: the same; url: section-5
spec: RFC7230; urlPrefix: https://tools.ietf.org/html/rfc7230
  type: grammar
    text: BWS; url: section-3.2.3
    text: OWS; url: section-3.2.3
    text: RWS; url: section-3.2.3
    text: quoted-string; url: section-3.2.6
    text: token; url: section-3.2.6
spec: RFC7231; urlPrefix: https://tools.ietf.org/html/rfc7231
  type: dfn
    url: section-3
      text: resource representation
      text: representation

spec: HTML; urlPrefix: https://html.spec.whatwg.org/
  type: dfn  
    text: run a worker
    text: initialising a new Document object
    text: update a style block
    text: the worker's documents
    text: Content-Security-Policy http-equiv processing instructions; url: attr-meta-http-equiv-content-security-policy
  type: element-attr
    text: ping; for: a
    text: nonce; for: script; url: attr-script-nonce

spec: SHA2; urlPrefix: http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
  type: dfn
    text: SHA-256; url: #
    text: SHA-384; url: #
    text: SHA-512; url: #
</pre>
<pre class="biblio">
{
  "ES2015": {
    "authors": [ "Allen Wirfs-Brock" ],
    "href": "http://www.ecma-international.org/ecma-262/6.0/index.html",
    "title": "ECMAScript® 2015 Language Specification",
    "publisher": "ECMA"
  },
  "SHA2": {
    "href": "http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf",
    "title": "FIPS PUB 180-4, Secure Hash Standard"
  }
}
</pre>
<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  [INTRODUCTION GOES HERE]

  ISSUE: CSP3 is a work in progress, and isn't quite yet ready for anyone to
  look at seriously. If you have suggestions, please
  <a href="https://github.com/w3c/webappsec-csp/issues/new">file a bug</a>!
  Otherwise, you'll probably want to look at the stable document at
  <a href="http://w3.org/TR/CSP2/">http://w3.org/TR/CSP2/</a>.

  <h3 id="examples">Examples</h3>

  <h4 id="example-basic">Control Execution</h4>

  <div class="example">
    MegaCorp Inc's developers want to protect themselves against cross-site
    scripting attacks. They can mitigate the risk of script injection by
    ensuring that their trusted CDN is the only origin from which script can
    load and execute. Moreover, they wish to ensure that no plugins can
    execute in their pages' contexts. The following policy has that effect:

    <pre>
      Content-Security-Policy: script-src https://cdn.example.com/scripts/; object-src 'none'
    </pre>
  </div>

  <h3 id="goals">Goals</h3>

  Content Security Policy aims to do to a few related things:

  1.  Mitigate the risk of content-injection attacks by giving developers
      fairly granular control over

      *   The resources which can be requested (and subsequently embedded or
          executed) on behalf of a specific {{Document}} or {{Worker}}

      *   The execution of inline script

      *   Dynamic code execution (via {{eval()}} and similar constructs)

      *   The application of inline style

  2.  Mitigate the risk of attacks which require a resource to be embedded
      in a malicious context ("Pixel Perfect", etc) by giving developers
      granular control over the origins which can embed a given resource.

  3.  Provide a policy framework which allows developers to tweak
      security-relevant settings.

  4.  Provide a reporting mechanism which allows developers to detect flaws
      being exploited in the wild.

  <h3 id="changes-from-level-2">Changes from Level 2</h3>

  This document describes an evolution of the Content Security Policy Level 2
  specification [[CSP2]]. The following is a high-level overview of the changes:

  1.  The specification has been rewritten from the ground up in terms of the
      [[FETCH]] specification, which should make it simpler to integrate CSP's
      requirements and restrictions with other specifications (and with
      Service Workers in particular).

  2.  The `frame-src` directive, which was deprecated in CSP Level
      2, has been removed.
</section>

<!-- Big Text: Framework -->
<section>
  <h2 id="framework">Framework</h2>

  <h3 id="framework-policy">Policies</h3>

  A <dfn local-lt="policies" export>policy</dfn> defines a set of allowed and
  restricted behaviors, and may be applied to a {{Window}} or
  {{WorkerGlobalScope}} as described in [[#initialise-global-object-csp]].
  
  Each policy has an associated <dfn for="policy">directive set</dfn>, which
  is a set of <a>directives</a> that define the policy's implications when
  applied.

  Each policy has an associated <dfn for="policy">disposition</dfn>, which is
  one of `null`, "`enforce`", or "`report`". The value is `null` unless
  otherwise specified.

  A <dfn export>serialized policy</dfn> is an ASCII string, consisting of a
  semicolon-delimited series of <a>serialized directives</a>, adhering to the
  following ABNF grammar [[!RFC5234]]:
 
  <pre dfn-type="grammar" link-type="grammar">
    <dfn>serialized-policy</dfn> = <a>serialized-directive</a> *( <a>OWS</a> ";" [ <a>OWS</a> <a>serialized-directive</a> ] )
                        ; <a>OWS</a> is defined in section 3.2.3 of RFC 7230
  </pre>

  <h4 id="parse-serialized-policy" dfn lt="parse a serialized policy">
    Parse a |serialized policy|
  </h4>

  Given a <a>serialized policy</a> (|serialized policy|), this
  algorithm will return a <a>policy</a> object. If the string cannot be parsed,
  the resulting <a>policy</a>'s <a>directive set</a> will be empty.

  1.  Let |policy| be a new <a>policy</a> with an empty <a>directive
      set</a>, and a `null` <a>type</a>.

  2.  For each |token| returned by
      <a lt="strictly split a string">strictly splitting</a> |serialized
      policy| on the U+003B SEMICOLON character (`;`):

      1.  <a>Strip leading and trailing whitespace</a> from |token|.

      2.  If |token| is an empty string, skip the remaining substeps
          and continue to the next item.

      3.  Let |directive name| be the result of
          <a lt="collect a sequence of characters">collecting a sequence of
          characters</a> from |token| which are not <a>space
          characters</a>.

      4.  If |policy|'s <a>directive set</a> contains a
          <a>directive</a> whose <a for="directive">name</a> is |directive
          name|, skip the remaining substeps and continue to the next item.

          The user agent SHOULD notify developers that a directive was ignored.
          A console warning might be appropriate, for example.

      5.  Let |directive value| be the result of
          <a lt="split a string on spaces">splitting |token| on
          spaces</a>.

      6.  Let |directive| be a new <a>directive</a> whose
          <a for="directive">name</a> is |directive name|, and
          <a for="directive">value</a> is |directive value|.

      7.  Add |directive| to |policy|'s <a>directive set</a>.

  3.  Return |policy|.

  <h4 id="parse-serialized-policy-list">
    Parse a serialized policy list
  </h4>

  Given a string (<var>list</var>) which contains a comma-delimited series of
  <a>serialized policies</a>, the following algorithm will return a list of
  <a>policies</a>:

  1.  Let <var>policies</var> be an empty list.

  2.  For each <var>token</var> returned by
      <a lt="split a string on commas">splitting <var>list</var> on commas</a>:

      1.  Let <var>policy</var> be the result of executing
          [[#parse-serialized-policy]] on <var>token</var>.

      2.  If <var>policy</var>'s <a>directive set</a> is empty, skip the
          remaining substeps, and continue to the next item.

      3.  Add <var>policy</var> to <var>policies</var>.

  3.  Return <var>policies</var>.

  <h3 id="framework-directives">Directives</h3>

  <a>Policies</a> contain a set of <dfn>directives</dfn>, each of which controls
  a specific behavior. The directives defined in this document are described in
  detail in [[#csp-directives]].

  Each <a>directive</a> is a <dfn for="directive">name</dfn> /
  <dfn for="directive">value</dfn> pair. The <a for="directive">name</a> is a
  non-empty string, and the <a>value</a> is a set of non-empty strings. The
  <a>value</a> set MAY be empty.

  A <dfn>serialized directive</dfn> is an ASCII string, consisting of one or more
  whitespace-delimited tokens, and adhering to the following ABNF [[!RFC5234]]:

  <pre dfn-type="grammar" link-type="grammar">
    <dfn>serialized-directive</dfn> = <a>directive-name</a> [ <a>RWS</a> <a>directive-value</a> ]
    <dfn>directive-name</dfn>       = 1*( <a>ALPHA</a> / <a>DIGIT</a> / "-" )
    <dfn>directive-value</dfn>      = *( %x09 / %x20-%x2B / %x2D-%x3A / %x3C-%7E )
                           ; Directive values may contain whitespace and <a>VCHAR</a> characters,
                           ; excluding ";" and ","

    ; <a>RWS</a> is defined in section 3.2.3 of RFC7230. <a>ALPHA</a>, <a>DIGIT</a>, and
    ; <a>VCHAR</a> are defined in Appendix B.1 of RFC 5234.
  </pre>

  <h4 id="framework-directive-source-list">Source Lists</h4>

  Many <a>directives</a>' <a>values</a> consist of <dfn>source lists</dfn>: sets
  of tokens which identify content that can be fetched and potentially embedded
  or executed. These tokens represent one of the following types of <dfn>source
  expression</dfn>:

  1.  Keywords such as <a grammar>`'none'`</a> and
      <a grammar>`'self'`</a> (which match nothing and the current
      URL's origin, respectively)

  2.  Serialized URLs such as `https://example.com/path/to/file.js`
      (which matches a specific file) or `https://example.com/`
      (which matches everything on that origin)

  3.  Schemes such as `https:` (which matches any resource having
      the specified scheme)

  4.  Hosts such as `example.com` (which matches any resource on
      the host, regardless of scheme) or `*.example.com` (which
      matches any resource on the host or any of its subdomains (and any of
      its subdomains' subdomains, and so on))

  5.  Nonces such as `'nonce-qwertyu12345'` (which can match specific
      elements on a page)

  6.  Digests such as `'sha256-abcd...'` (which can match specific
      elements on a page)

  A <dfn>serialized source list</dfn> is an ASCII string, consisting of a
  space-delimited series of <a>source expressions</a>, adhering to the
  following ABNF grammar [[!RFC5234]]:

  <pre dfn-type="grammar" link-type="grammar">
    <dfn>serialized-source-list</dfn> = ( <a>source-expression</a> *( <a>RWS</a> <a>source-expression</a> ) ) / "<dfn>'none'</dfn>"
    <dfn>source-expression</dfn>      = <a>scheme-source</a> / <a>host-source</a> / <a>keyword-source</a>
                             / <a>nonce-source</a> / <a>hash-source</a>

    ; Schemes:
    <dfn>scheme-source</dfn> = <a>scheme</a> ":"
                    ; <a>scheme</a> is defined in section 3.1 of RFC 3986.

    ; Hosts: "example.com" / "*.example.com" / "https://*.example.com:12/path/to/file.js"
    <dfn>host-source</dfn> = [ <a>scheme-part</a> "://" ] <a>host-part</a> [ <a>port-part</a> ] [ <a>path-part</a> ]
    <dfn>scheme-part</dfn> = <a>scheme</a>
    <dfn>host-part</dfn>   = "*" / [ "*." ] 1*<a>host-char</a> *( "." 1*<a>host-char</a> )
    <dfn>host-char</dfn>   = <a>ALPHA</a> / <a>DIGIT</a> / "-"
    <dfn>port-part</dfn>   = ":" ( 1*<a>DIGIT</a> / "*" )
    <dfn>path-part</dfn>   = <a>path</a>
                  ; <a>path</a> is defined in section 3.3 of RFC 3986.
   
    ; Keywords:
    <dfn>keyword-source</dfn> = "<dfn>'self'</dfn>" / "<dfn>'unsafe-inline'</dfn>" / "<dfn>'unsafe-eval'</dfn>" 

    ; Nonces: 'nonce-[nonce goes here]'
    <dfn>nonce-source</dfn>  = "'nonce-" <a>base64-value</a> "'"
    <dfn>base64-value</dfn>  = 1*( <a>ALPHA</a> / <a>DIGIT</a> / "+" / "/" )*2( "=" ) 

    ; Digests: 'sha256-[digest goes here]'
    <dfn>hash-source</dfn>    = "'" <a>hash-algorithm</a> "-" <a>base64-value</a> "'"
    <dfn>hash-algorithm</dfn> = "sha256" / "sha384" / "sha512"
  </pre>

  The <a grammar>host-char</a> production intentionally contains only ASCII
  characters; internationalized domain names cannot be entered directly as part
  of a <a>serialized policy</a>, but instead MUST be Punycode-encoded
  [[!RFC3492]]. For example, the domain `üüüüüü.de` MUST be represented as
  `xn--tdaaaaaa.de`.

  Note: Though IP address do match the grammar above, only
  `127.0.0.1` will actually match a URL when used in a source
  expression (see [[#match-url-to-source-list]] for details). The security
  properties of IP addresses are suspect, and authors ought to prefer hostnames
  whenever possible.

  A {{URL}} <dfn>matches a source list</dfn> if the algorithm in
  [[#match-url-to-source-list]] returns `Matches`.

  <h3 id="framework-violation">Violations</h3>

  A <dfn>violation</dfn> represents an action or resource which goes against the
  <a>policies</a> associated with a <a>global object</a>.

  Each <a>violation</a> has a <dfn for="violation">resource URL</dfn>, which is
  either `null` or a {{URL}}.

  Each <a>violation</a> has a <dfn for="violation">violated policy</dfn>, which
  is a <a>policy</a>.

  Each <a>violation</a> has an <dfn for="violation">violated directive</dfn>,
  which is a non-empty string representing the <a>directive</a> which was
  violated.

  Each <a>violation</a> has an
  <dfn for="violation" id="violation-effective-directive">effective directive</dfn>
  which is a non-empty string representing the <a>directive</a> whose
  enforcement caused the violation.
  
  Note: This generally the same as the <a for="violation">violated directive</a>
  but will differ in cases where <a>fetch directives</a> are not explicitly
  present in a <a>policy</a>, but fall back to <a>default-src</a>.

  Each <a>violation</a> has a <dfn for="violation">source file</dfn>, which is
  either `null` or a {{URL}}.

  Each <a>violation</a> has a <dfn for="violation">line number</dfn>, which is
  a non-negative integer.

  Each <a>violation</a> has a <dfn for="violation">column number</dfn>, which is
  a non-negative integer.
</section>

<!-- Big Text: Delivery -->
<section>
  <h2 id="policy-delivery">
    Policy Delivery
  </h2>

  A server MAY declare a <a>policy</a> for a particular <a>resource
  representation</a> via an HTTP response header field whose value is a
  <a>serialized policy</a>. This mechanism is defined in detail in
  [[#csp-header]] and [[#cspro-header]], and the integration with Fetch
  and HTML is described in [[#fetch-integration]] and [[#html-integration]].

  A <a>policy</a> may also be declared inline in an HTML document via a
  <{meta}> element's <{meta/http-equiv}> attribute, as described in
  [[#meta-element]].

  <h3 id="csp-header">
    The `Content-Security-Policy` HTTP Response Header Field
  </h3>

  The <dfn>`Content-Security-Policy`</dfn> HTTP response header field
  is the preferred mechanism for delivering a policy from a server to a client.
  The header's value is represented by the following ABNF [[!RFC5234]]:

  <pre>
    Content-Security-Policy = 1#<a grammar>serialized-policy</a>
  </pre>

  <div class="example">
    <pre>
      <a>Content-Security-Policy</a>: script-src 'self';
                               reports /csp-reporting-endpoint
    </pre>
  </div>

  A server MAY send different `Content-Security-Policy` header field
  values with different <a>representations</a> of the same resource.

  A server SHOULD NOT send more than one HTTP response header field named
  "`Content-Security-Policy`" with a given <a>resource
  representation</a>.

  When the user agent receives a `Content-Security-Policy` header field, it
  MUST <a lt="parse a serialized policy">parse</a> and <a>enforce</a> each
  <a>serialized policy</a> it contains as described in [[#fetch-integration]],
  [[#html-integration]].

  <h3 id="cspro-header">
    The `Content-Security-Policy-Report-Only` HTTP Response Header Field
  </h3>

  The <dfn>`Content-Security-Policy-Report-Only`</dfn> HTTP response
  header field allows web developers to experiment with policies by monitoring
  (but not enforcing) their effects. The header's value is represented by the
  following ABNF [[!RFC5234]]:

  <pre>
    Content-Security-Policy-Report-Only = 1#<a grammar>serialized-policy</a>
  </pre>

  This header field allows developers to piece together their security policy in
  an iterative fashion, deploying a report-only policy based on their best
  estimate of how their site behaves, watching for violation reports, and then
  moving to an enforced policy once they've gained confidence in that behavior.

  <div class="example">
    <pre>
      <a>Content-Security-Policy-Report-Only</a>: script-src 'self';
                                           reports /csp-reporting-endpoint
    </pre>
  </div>

  A server MAY send different `Content-Security-Policy-Report-Only`
  header field values with different <a>representations</a> of the same
  resource.

  A server SHOULD NOT send more than one HTTP response header field named
  "`Content-Security-Policy-Report-Only`" with a given <a>resource
  representation</a>.

  When the user agent receives a `Content-Security-Policy-Report-Only` header
  field, it MUST <a lt="parse a serialized policy">parse</a> and <a>monitor</a>
  each <a>serialized policy</a> it contains as described in
  [[#fetch-integration]] and [[#html-integration]].

  Note: The `<a>Content-Security-Policy-Report-Only</a>` header is
  <strong>not</strong> supported inside a <{meta}> element.

  <h3 id="meta-element">
    The `<meta>` element
  </h3>

  A {{Document}} may deliver a policy via one or more HTML <{meta}> elements
  whose <{meta/http-equiv}> attributes are an <a>ASCII case-insensitive
  match</a> for the string "`Content-Security-Policy`". For example:

  <div class="example">
    <pre>
      &lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'"&gt;
    </pre>
  </div>

  Implementation details can be found in HTML's <a>`Content-Security-Policy`
  `http-equiv` processing instructions</a> [[!HTML]].

  Note: The `<a>Content-Security-Policy-Report-Only</a>` header is <em>not</em>
  supported inside a <{meta}> element. Neither are the `report-uri`,
  `frame-ancestors`, and `sandbox` directives.

  ISSUE: Why `sandbox`? Can we loosen that?

  Authors are <em>strongly encouraged</em> to place <{meta}> elements as early
  in the document as possible, because policies in <{meta}> elements are not
  applied to content which precedes them. In particular, note that resources
  fetched or prefetched using the `Link` HTTP response header
  field, and resources fetched or prefetched using <{link}> and <{script}>
  elements which precede a <{meta}>-delivered policy will not be blocked.

  Note: A policy specified via a <{meta}> element will be enforced along with
  any other policies active for the protected resource, regardless
  of where they're specified. The general impact of enforcing multiple
  policies is described in [[#multiple-policies]].

  Note: Modifications to the <{meta/content}> attribute of a <{meta}> element
  after the element has been parsed will be ignored.
</section>

<!-- Big Text: Integration -->
<section>
  <h2 id="integrations">Integrations</h2>

  <em>This section is non-normative.</em>

  This document defines a set of algorithms which are used in other
  specifications in order to implement the functionality. These
  integrations are outlined here for clarity, but those external
  documents are the normative references which ought to be consulted for
  detailed information.

  <h3 id="fetch-integration">
    Integration with Fetch
  </h3>

  A number of <a>directives</a> control resource loading in one way or
  another. This specification provides algorithms which allow Fetch to make
  decisions about whether or not a particular <a>request</a> should be blocked
  or allowed, and about whether a particular <a>response</a> should be replaced
  with a <a>network error</a>.

  1.  [[#should-block-request]] is called as part of step #4 of its <a>Main
      Fetch</a> algorithm.

  2.  [[#should-block-response]] is called as part of step #12 of its <a>Main
      Fetch</a> algorithm.

      Note: The <a>`frame-ancestors`</a> check is handled here, inside
      [[#should-block-response]].

  ISSUE: Give Anne a patch to Fetch to make this bit true.

  A <a>policy</a> is generally enforced upon a <a>global object</a>, but the
  user agent needs to <a lt="parse a serialized policy">parse</a> any policy
  delivered via an HTTP response header field before any <a>global object</a>
  is created in order to handle directives like <a>frame-ancestors</a>. To
  that end, Anne SHOULD accept the following monkey patches to [[!FETCH]] (or
  come up with better ideas):

  1.  A <a>response</a> has an associated
      <dfn for="response" id="response-policy-list">policy list</dfn> which
      contains any policy objects delivered in the <a>response</a>'s
      <a for="response">header list</a>. The list is empty unless otherwise
      specified.

  2.  Insert the following steps after <a>HTTP fetch</a>'s current step 2.2:

      3.  Execute [[#set-response-policy-list]] on <var>response</var>.

  3.  Insert the following steps before the <a>HTTP-network fetch</a>'s current
      step 6:

      6.  Execute [[#set-response-policy-list]] on <var>response</var>.

  Note: These two additions should ensure that <a>responses</a>'s
  <a for="response">policy lists</a> are set, regardless of how the
  <a>response</a> is created. If we hit the network (via
  <a>HTTP-network fetch</a>, then we parse the policy before we handle the
  `Set-Cookie` header. If we get a response from a Service Worker (via <a>HTTP
  fetch</a>, we'll process its <a for="response">policy list</a> before handing
  the response back to our caller.

  <h4 id="set-response-policy-list">
    Set <var>response</var>'s `policy list`
  </h4>

  Given a <a>response</a> (<var>response</var>), this algorithm evaluates its
  <a for="response">header list</a> for <a>serialized policy</a> values, and
  populates its <a for="response">policy list</a> accordingly:

  1.  Let <var>policies to enforce</var> be the result of executing
      [[#parse-serialized-policy-list]] on the result of
      <a lt="parse a header value">parsing</a> `Content-Security-Policy`
      in <var>response</var>'s <a for="response">header list</a>.

  2.  For each <var>policy</var> in <var>policies to enforce</var>:

      1.  Set <var>policy</var>'s <a for="policy">disposition</a> to
          "`enforce`".

      2.  Insert <var>policy</var> into <var>response</var>'s
          <a for="response">policy list</a>.

  3.  Let <var>policies to report</var> be the result of executing
      [[#parse-serialized-policy-list]] on the result of
      <a lt="parse a header value">parsing</a>
      `Content-Security-Policy-Report-Only` in <var>response</var>'s
      <a for="response">header list</a>.

  4.  For each <var>policy</var> in <var>policies to report</var>:

      1.  Set <var>policy</var>'s <a for="policy">disposition</a> to
          "`report`".

      2.  Insert <var>policy</var> into <var>response</var>'s
          <a for="response">policy list</a>.

  <h4 id="should-block-request">
    Should <var>request</var> be blocked by Content Security Policy?
  </h4>

  Given a <a>request</a> (<var>request</var>), this algorithm returns
  `Blocked` or `Allowed` and reports violations based on <var>request</var>'s
  <a for="request">client</a>'s Content Security Policy.

  1.  Let <var>policy list</var> be <var>request</var>'s
      <a for="request">client</a>'s <a>global object</a>'s
      <a for="global object">policy list</a>.

  2.  Let <var>result</var> be "`Allowed`".

  3.  For each <var>policy</var> in <var>policy list</var>:

      1.  Let <var>source list</var> be the <a>effective source list</a> for
          <var>request</var> and <var>policy</var>.

      2.  If <var>source list</var> is `null`, then skip to the next
          <var>policy</var>.

      3.  If the result of executing [[#match-url-to-source-list]] on
          <var>request</var>'s <a for="request">url</a> is `Matches`, then skip
          to the next <var>policy</var>.

      4.  <a>Report a violation</a> for <var>policy</var>, <var>directive</var>
          and <var>request</var>.

      5.  If <var>policy</var>'s <a for="policy">disposition</a> is "`enforce`",
          set <var>result</var> to "`Blocked`".

  4.  Return <var>result</var>.

  <h4 id="should-block-response">
    Should <var>response</var> to <var>request</var> be blocked by Content
    Security Policy?
  </h4>

  Given a <a>response</a> (<var>response</var>) and a <a>request</a>
  (<var>request</var>), this algorithm returns `Blocked` or
  `Allowed`, and reports violations based on <var>request</var>'s
  <a for="request">client</a>'s Content Security Policy.

  1.  Let <var>policy list</var> be <var>request</var>'s
      <a for="request">client</a>'s <a>global object</a>'s
      <a for="global object">policy list</a>.

  2.  Let <var>result</var> be "`Allowed`".

  3.  For each <var>policy</var> in <var>policy list</var>:

      1.  Let <var>source list</var> be the <a>effective source list</a> for
          <var>request</var> and <var>policy</var>.

      2.  If <var>source list</var> is `null`, then skip to the next
          <var>policy</var>.

      3.  If the result of executing [[#match-url-to-source-list]] on
          <var>response</var>'s <a for="response">url</a> is `Matches`, then skip
          to the next <var>policy</var>.

      4.  <a>Report a violation</a> for <var>policy</var>, <var>directive</var>
          and <var>request</var>.

      5.  If <var>policy</var>'s <a for="policy">disposition</a> is "`enforce`",
          set <var>result</var> to "`Blocked`".

  4.  If <var>result</var>is "`Blocked`", return "`Blocked`".

  5.  If <var>request</var>'s <a for="request">destination</a> is "`document`"
      <em>and</em> the <var>request</var>'s <a for="request">target browsing
      context</a> is a <a>nested browsing context</a>:

      1.  For each <var>policy</var> in <var>response</var>'s
          <a for="response">policy list</a>:

          1.  Let <var>source list</var> be the value of <var>policy</var>'s
              <a for="policy">directive set</a>'s <a>`frame-ancestors`</a>
              directive.

          2.  If <var>source list</var> is `null`, then skip to the next
              <var>policy</var>.

          3.  For each <var>ancestor</var> of the <var>request</var>'s
              <a for="request">target browsing context</a>'s <a>ancestor
              browsing context</a>s:

              1.  If [[#match-url-to-source-list]] returns `Matches` when
                  executed upon <var>ancestor</var>'s <a>active document</a>'s
                  <a for="Document">URL</a> and <var>source list</var>, skip
                  to the next <var>ancestor</var>.

              2.  <a>Report a violation</a> for <var>policy</var>,
                  <a>`frame-ancestors`</a>, and <var>request</var>.

              3.  If <var>policy</var>'s <a for="policy">disposition</a> is
                  "`enforce`", set <var>result</var> to "`Blocked`".

              4.  Skip to the next <var>policy</var>.

  6.  Return <var>result</var>.


  <h3 id="html-integration">
    Integration with HTML
  </h3>
  
  1.  The {{Window}} and {{WorkerGlobalScope}} objects have a
      <dfn for="global object" id="global-object-policy-list">policy list</dfn>,
      which holds all the <a>policy</a> objects which are active for a given
      context. This list is empty unless otherwise specified, and is populated
      via the [[#initialise-global-object-csp]] algorithm.

  2.  A <a>policy</a> is <dfn>enforced</dfn> or <dfn>monitored</dfn> for an
      <a>global object</a> by inserting it into the <a>global object</a>'s
      <a for="global object">policy list</a>.

  3.  [[#initialise-global-object-csp]] is called during the <a>initialising a
      new `Document` object</a> and <a>run a worker</a> algorithms in order to
      bind a set of <a>policy</a> objects associated with a <a>response</a> to a
      newly created <a>global object</a>.

      ISSUE: The algorithm is named "creating a new `Document` object" in W3C's
      HTML, and isn't well-integrated with Fetch.

      ISSUE: Need to monkey-patch these in: something like "Set the `Window`
      object's `policy list` to the `policy list` of the resource used to
      generate the document.

  4.  [[#match-node-to-policy]] is called during the <a>prepare a script</a> and
      <a>update a `style` block</a> algorithms in order to determine whether or
      not an inline script or style block is allowed to execute.

      ISSUE: The <a>update a `style` block</a> algorithm does not exist in
      W3C's HTML.

      ISSUE: The `nonce` attribute for <{script}> and <{style}> were added to
      WHATWG's HTML in
      <a href="https://github.com/whatwg/html/commit/882803c4cc8fba2fa5472b76f628d95cc82c421d">whatwg/html@882803c</a>.
      They have not yet been added to W3C's HTML.

      ISSUE: Need to monkey-patch these in: something like "If
      [[#match-node-to-policy]] returns `Does Not Match` when executed upon the
      element and the element's `Document`'s <a>global object</a>'s
      `policy list`, abort these steps."

  5.  <a>Policies</a> are <a>enforced</a> during processing of the <{meta}>
      element's <{meta/http-equiv}>.

      ISSUE: This processing was added to WHATWG's HTML in
      <a href="https://github.com/whatwg/html/commit/5064a629f22bef29839ab4dc6f1ceef17f010bc5">whatwg/html@5064a62</a>.
      It has not yet been added to W3C's HTML.

  6.  A {{Document}}'s <dfn>embedding document</dfn> is the {{Document}}
      <a lt="nested through">through which</a> the {{Document}}'s
      <a>browsing context</a> is nested.

  7.  [[#allow-base-for-document]] is called during <{base}>'s <a>set the frozen
      base URL</a> algorithm to ensure that the <{base/href}> attribute's value
      is valid.

      ISSUE: Need to add this to HTML.

  <h4 id="initialise-global-object-csp">
    Initialise <var>global object</var>'s `policy list`
  </h4>

  Given a <a>global object</a> (<var>global</var>), and a <a>response</a>
  (<var>response</var>), the user agent performs the following steps in order
  to initialize <var>global</var>'s <a for="global object">policy list</a>:

  1.  If <var>response</var>'s <a for="response">url</a>'s {{URL/scheme}} is a
      <a>local scheme</a>:

      1.  Let <var>documents</var> be an empty list.

      2.  If <var>global</var> is a {{Window}} object, and <var>global</var>'s
          {{Window/document}} has an <a>embedding document</a>
          (<var>document</var>), then add <var>document</var> to
          <var>documents</var>.

      3.  Otherwise <var>global</var> is a {{WorkerGlobalScope}} object, so, add 
          each of <var>global</var>'s
          <a lt="the worker's documents">document</a>s to <var>documents</var>.

      4.  For each <var>document</var> in <var>documents</var>:

          1.  For each <var>policy</var> in <var>document</var>'s <a>global
              object</a>'s <a for="global object">policy list</a>:

              1.  Insert an alias to <var>policy</var> in <var>global</var>'s
                  <a for="global object">policy list</a>.

      Note: <a>local scheme</a> includes `about:`, and this algorithm will
      therefore alias the <a>embedding document</a>'s policies for <a>an iframe
      `srcdoc` `Document`</a>.

  2.  For each <var>policy</var> in <var>response</var>'s
      <a for="response">policy list</a>, insert <var>policy</var> into
      <var>global</var>'s <a for="global object">policy list</a>.
</section>

<!-- Big Text: Reporting -->
<section>
  <h2 id="reporting">
    Reporting
  </h2>

  <dfn>Report a violation</dfn>.

  ISSUE: Need an algorithm here, right? :)
</section>

<!-- Big Text: Directives -->
<section>
  <h2 id="csp-directives">
    Content Security Policy Directives
  </h2>
  
  This specification defines a number of types of <a>directives</a> which allow
  developers to control certain aspects of their sites' behavior. The defined
  directives fall into one of several categories:


  2.  ...

  To mitigate the risk of cross-site scripting attacks, web developers SHOULD
  include directives that regulate sources of script and plugins. They can do
  so by including:

  *   Both the <a>script-src</a> and <a>object-src</a> directives, or
  *   a <a>default-src</a> directive

  In either case, developers SHOULD NOT include either
  <a grammar>`'unsafe-inline'`</a>, or `data:` as valid
  sources in their policies. Both enable XSS attacks by allowing code to be
  included directly in the document itself; they are best avoided completely.

  <h3 id="directives-fetch">
    Fetch Directives
  </h3>
  
  <dfn>Fetch directives</dfn> control the locations from which certain resource
  types may be loaded. For instance, <a>script-src</a> allows developers to
  whitelist trusted sources of script to execute on a page, while
  <a>font-src</a> controls the sources of web fonts.

  <h4 id="directive-child-src">`child-src`</h4>

  The <dfn>child-src</dfn> directive governs the creation of <a>nested browsing
  contexts</a> and Worker execution contexts. The syntax for the directive's
  name and value is described by the following ABNF:

  <pre>
    directive-name  = "child-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  This directive controls <a>requests</a> which will populate a frame or a
  worker. More formally, <a>requests</a> falling into one of the
  following categories:
  
  *  <a for="request">destination</a> is "`document`", and whose
     <a for="request">target browsing context</a> is a <a>nested browsing
     context</a> (e.g. requests which will populate an <{iframe}> or <{frame}>
     element)
     
  *  <a for="request">destination</a> is either "`serviceworker`",
     "`sharedworker`", or "`worker`" (which are fed to the <a>run a worker</a>
     algorithm for {{ServiceWorker}}, {{SharedWorker}}, and {{Worker}},
     respectively).

  <div class="example">
    Given a page with the following Content Security Policy:

    <pre>
      Content-Security-Policy: <a>child-src</a> https://example.com/
    </pre>

    Fetches for the following code will all return network errors, as the URLs
    provided do not match `child-src`'s <a>source list</a>:

    <pre>
      &lt;iframe src="https://not-example.com"&gt;&lt;/iframe&gt;
      &lt;script&gt;
        var blockedWorker = new Worker("data:application/javascript,...");
      &lt;/script&gt;
    </pre>
  </div>

  <h4 id="directive-connect-src">`connect-src`</h4>

  The <dfn>connect-src</dfn> directive restricts the URLs which can be loaded
  using script interfaces. The syntax for the directive's name and value is
  described by the following ABNF:

  <pre>
    directive-name  = "connect-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  This directive controls <a>requests</a> which transmit or receive data from
  other origins. More formally, <a>requests</a> falling into one of the
  following categories: 
 
  *   <a for="request">initiator</a> is "`fetch`" (e.g. `fetch()`)
  *   <a for="request">type</a> is "", and whose
      <a for="request">destination</a> is "`subresource`". (e.g. [[XHR]],
      [[EVENTSOURCE]], <{a}>'s <{a/ping}>, and [[BEACON]]

  This directive <em>also</em> controls WebSocket [[WEBSOCKETS]] connections,
  though those aren't technically part of Fetch.  

  <div class="example">
    JavaScript offers a few mechanisms that directly connect to an external
    server to send or receive information. `EventSource` maintains an open
    HTTP connection to a server in order to receive push notifications,
    `WebSockets` open a bidirectional communication channel between your
    browser and a server, and `XMLHttpRequest` makes arbitrary HTTP requests
    on your behalf. These are powerful APIs that enable useful functionality,
    but also provide tempting avenues for data exfiltration.

    The `connect-src` directive allows you to ensure that these and similar
    sorts of connections are only opened to origins you trust. Sending a
    policy that defines a list of source expressions for this directive is
    straightforward. For example, to limit connections to only
    `https://example.com`, send the following header:

    <pre>
      Content-Security-Policy: <a>connect-src</a> https://example.com/
    </pre>

    Fetches for the following code will all return network errors, as the URLs
    provided do not match `connect-src`'s <a>source list</a>:

    <pre>
      &lt;a ping="https://not-example.com"&gt;...
      &lt;script&gt;
        var xhr = new XMLHttpRequest();
        xhr.open('GET', 'https://not-example.com/');
        xhr.send();

        var ws = new WebSocket("https://not-example.com/");
        
        var es = new EventSource("https://not-example.com/");

        navigator.sendBeacon("https://not-example.com/", { ... });
      &gt;/script&gt;
    </pre>
  </div>

  <h4 id="directive-default-src">`default-src`</h4>

  The <dfn>default-src</dfn> directive serves as a fallback for the other 
  <a>fetch directives</a>. The syntax for the directive's name and value is described by
  the following ABNF:

  <pre>
    directive-name  = "default-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  If a <a>default-src</a> directive is present, its value will be used as the
  <a>effective source list</a> for any <a>fetch directive</a> which is not
  explicitly present in the policy.

  That is, given `default-src 'none'; script-src 'self'`, script requests will
  use `'self'` as the <a>effective source list</a> to match against. Other
  requests will use `'none'`. This is spelled out in more detail in the
  [[#match-request-to-policy]] algorithm.

  <div class="example">
    The following header:

    <pre>
      <a>Content-Security-Policy</a>: <a>default-src</a> <a grammar>'self'</a>
    </pre>

    will have the same behavior as the following header:

    <pre>
      <a>Content-Security-Policy</a>: <a>child-src</a> <a grammar>'self'</a>
                               <a>connect-src</a> <a grammar>'self'</a>
                               <a>font-src</a> <a grammar>'self'</a>
                               <a>img-src</a> <a grammar>'self'</a>
                               <a>media-src</a> <a grammar>'self'</a>
                               <a>object-src</a> <a grammar>'self'</a>
                               <a>script-src</a> <a grammar>'self'</a>
                               <a>style-src</a> <a grammar>'self'</a>
    </pre>

    That is, when `default-src` is set, every <a>fetch directive</a> that isn't
    explicitly set will fall back to the value `default-src` specifies.
  </div>
  <div class="example">
    There is no inheritance. If a `script-src` directive is explicitly
    specified, for example, then the value of `default-src` has no influence on
    script requests. That is, the following header:

    <pre>
      <a>Content-Security-Policy</a>: <a>default-src</a> <a grammar>'self'</a>, <a>script-src</a> https://example.com
    </pre>

    will have the same behavior as the following header:

    <pre>
      <a>Content-Security-Policy</a>: <a>child-src</a> <a grammar>'self'</a>
                               <a>connect-src</a> <a grammar>'self'</a>
                               <a>font-src</a> <a grammar>'self'</a>
                               <a>img-src</a> <a grammar>'self'</a>
                               <a>media-src</a> <a grammar>'self'</a>
                               <a>object-src</a> <a grammar>'self'</a>
                               <a>script-src</a> https://example.com
                               <a>style-src</a> <a grammar>'self'</a>
    </pre>

    Given this behavior, one good way to build a policy for a site would be to
    begin with a `default-src` of `'none'`, and to build up a policy from there
    which allowed only those resource types which are necessary for the
    particular page the policy will apply to.
  </div>

  <h4 id="directive-font-src">`font-src`</h4>

  The <dfn>font-src</dfn> directive restricts the URLs from which font resources
  may be loaded. The syntax for the directive's name and value is described by
  the following ABNF:

  <pre>
    directive-name  = "font-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  <div class="example">
    Given a page with the following Content Security Policy:

    <pre>
      Content-Security-Policy: <a>font-src</a> https://example.com/
    </pre>

    Fetches for the following code will return a network errors, as the URL
    provided do not match `font-src`'s <a>source list</a>:

    <pre>
      &lt;style&gt;
        @font-face {
          font-family: "Example Font";
          src: url("https://not-example.com/font");
        }
        body {
          font-family: "Example Font";
        }
      &lt;/style&gt;
    </pre>
  </div>

  <h4 id="directive-img-src">`img-src`</h4>

  The <dfn>img-src</dfn> directive restricts the URLs from which image resources
  may be loaded. The syntax for the directive's name and value is described by
  the following ABNF:

  <pre>
    directive-name  = "img-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  <div class="example">
    Given a page with the following Content Security Policy:

    <pre>
      Content-Security-Policy: <a>img-src</a> https://example.com/
    </pre>

    Fetches for the following code will return a network errors, as the URL
    provided do not match `img-src`'s <a>source list</a>:

    <pre>
      &lt;img src="https://not-example.com/img"&gt;
    </pre>
  </div>

  <h4 id="directive-media-src">`media-src`</h4>

  The <dfn>media-src</dfn> directive restricts the URLs from which video, audio,
  and associated text track resources may be loaded. The syntax for the
  directive's name and value is described by the following ABNF:

  <pre>
    directive-name  = "media-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  <div class="example">
    Given a page with the following Content Security Policy:

    <pre>
      Content-Security-Policy: <a>media-src</a> https://example.com/
    </pre>

    


    Fetches for the following code will return a network errors, as the URL
    provided do not match `media-src`'s <a>source list</a>:

    <pre>
      &lt;img src="https://not-example.com/img"&gt;
    </pre>
  </div>

  <h4 id="directive-object-src">`object-src`</h4>

  The <dfn>object-src</dfn> directive restricts the URLs from which plugins may
  be loaded. The syntax for the directive's name and value is described by the
  following ABNF:

  <pre>
    directive-name  = "object-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  <div class="example">
    Given a page with the following Content Security Policy:

    <pre>
      Content-Security-Policy: <a>object-src</a> https://example.com/
    </pre>

    Fetches for the following code will return a network errors, as the URL
    provided do not match `object-src`'s <a>source list</a>:

    <pre>
      &lt;embed src="https://not-example.com/flash"&gt;&lt;/embed&gt;
      &lt;object data="https://not-example.com/flash"&gt;&lt;/object&gt;
      &lt;applet archive="https://not-example.com/flash"&gt;&lt;/applet&gt;
    </pre>
  </div>

  If plugin content is loaded without an associated URL (perhaps an <{object}>
  element lacks a <{object/data}> attribute, but loads some default plugin based
  on the specified `type`), it MUST be blocked if `object-src`'s value is
  `'none'`, but will otherwise be allowed. The <a>`plugin-types`</a> directive
  can be used to control these kinds of plugins with more granularity.

  Note: The `object-src` directive acts upon any request made on behalf of
  an <{object}>, <{embed}>, or <{applet}> element. This includes requests
  which would populate the <a>nested browsing context</a> generated by the
  former two (also including navigations). This is true even when the data is
  semantically equivalent to content which would otherwise be restricted by
  another directive, such as an <{object}> element with a `text/html` MIME
  type.

  <h4 id="directive-script-src">`script-src`</h4>

  The <dfn>script-src</dfn> directive restricts the locations from which scripts
  may be executed. This includes not only URLs loaded directly into <{script}>
  elements, but also things like inline script blocks and XSLT stylesheets
  [[XSLT]] which can trigger script execution. The syntax for the directive's
  name and value is described by the following ABNF:

  <pre>
    directive-name  = "script-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>


  <h4 id="directive-style-src">`style-src`</h4>

  The <dfn>style-src</dfn> directive restricts the locations from which style
  may be applied to a {{Document}}. The syntax for the directive's name and
  value is described by the following ABNF:

  <pre>
    directive-name  = "style-src"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  <h4 id="fetch-directive-matching-url">URL Matching Algorithms</h4>

  <h5 id="match-request-to-policy">
    Does |request| match |policy|?
  </h5>

  1.  Let |source list| be the result of executing
      [[#effective-source-list-for-request]] on |request| and |policy|.

  2.  Return the result of executing [[#match-url-to-source-list]] on
      |request|'s <a for="request">url</a> and |source list|.

  <h5 id="match-url-to-source-list">
    Does |url| match |source list|?
  </h5>

  Given a {{URL}} (|url|), and a <a>source list</a> (|source list|), this
  algorithm returns "`Matches`" if the URL matches one or more source
  expressions in |source list|, or "`Does Not Match`" otherwise:

  1.  If |source list| is `null`, return "`Matches`".

  2.  If |source list| contains a single item which is a <a>case-sensitive</a>
      match for the string "`'none'`", return `Does Not Match`.

  3.  For each |expression| in |source list|:

      1.  If [[#match-url-to-source-expression]] returns "`Matches`" when
          executed upon |url| and |expression|, return "`Matches`".

  4.  Return "`Does Not Match`".

  <h5 id="match-url-to-source-expression">
    Does |url| match |expression| in |origin| with |redirect count|?
  </h5>

  Given a {{URL}} (|url|), a <a>source expression</a> (|expression|), an
  <a>origin</a> (|origin|), and a number (|redirect count|), this algorithm
  returns "`Matches`" if |url| matches |expression|, and "`Does Not Match`"
  otherwise.

  Note: |origin| is the <a>origin</a> of the resource relative to which the
  |expression| should be resolved. "`'self'`", for instance, will have distinct
  meaning depending on that bit of context.

  1.  If |expression| is the string "*", and |url|'s {{URL/scheme}} is not a
      <a>local scheme</a>, return "`Matches`".

  2.  If |expression| matches the <a grammar>`scheme-source`</a> grammar:

      1.  If |url|'s {{URL/scheme}} is an <a>ASCII case-insensitive match</a>
          for |expression|'s <a grammar>`scheme-part`</a>, return "`Matches`".

      2.  Return "`Does Not Match`".

  3.  If |expression| matches the <a grammar>`host-source`</a> grammar:
  
      1.  If |url|'s {{URL/host}} is `null`, return "`Does Not Match`".

      2.  If |expression| has a <a grammar>`scheme-part`</a> that is not an
          <a>ASCII case-insensitive match</a> for |url|'s {{URL/scheme}}, return
          "`Does Not Match`".

      3.  If |expression| does not have a <a grammar>`scheme-part`</a>, then
          return "`Does Not Match`" unless one of the following conditions is
          met:

          1.  |origin|'s {{URL/scheme}} is an <a>ASCII case-insensitive
              match</a> for "`HTTP`", and |url|'s {{URL/scheme}} is an <a>ASCII
              case-insensitive match</a> for either "`HTTP`" or "`HTTPS`".

          2.  |origin|'s {{URL/scheme}} is an <a>ASCII case-insensitive
              match</a> for |url|'s {{URL/scheme}}.
      
      4.  If the first character of |expression|'s <a grammar>`host-part`</a>
          is an U+002A ASTERISK character (`*`):
          
          1.  Let |remaining| be the result of removing the leading "`*`" from
              |expression|.

          2.  If |remaining| (including the leading U+002E FULL STOP character
              (`.`)) is not an <a>ASCII case-insensitive match</a> for the
              rightmost characters of |url|'s {{URL/host}}, then return "`Does
              Not Match`".

      5.  If the first character of |expression|'s <a grammar>`host-part`</a>
          is not an U+002A ASTERISK character (`*`), and |url|'s {{URL/host}}
          is not an <a>ASCII case-insensitive match</a> for |expression|'s
          <a grammar>`host-part`</a>, return "`Does Not Match`".

      6.  If |expression|'s <a grammar>`host-part`</a> matches the
          <a grammar>IPv4address</a> rule from [[!RFC3986]], and is not
          "`127.0.0.1`"; or if |expression|'s <a grammar>`host-part`</a> is an
          <a>IPv6 address</a>, return "`Does Not Match`".

          Note: A future version of this specification may allow literal IPv6
          and IPv4 addresses, depending on usage and demand. Given the weak
          security properties of IP addresses in relation to named hosts,
          however, authors are encouraged to prefer the latter whenever
          possible.

      7.  If |expression| does not contain a <a grammar>`port-part`</a>, and
          |url|'s {{URL/port}} is not the <a>default port</a> for |url|'s
          {{URL/scheme}}, return "`Does Not Match`".

      8.  If |expression| does contain a <a grammar>`port-part`</a>:

          1.  If |expression|'s <a grammar>`port-part`</a> is not "`*`", and
              is not the same number as |url|'s {{URL/port}}, return "`Does Not
              Match`".

      9.  If |expression| contains a non-empty <a grammar>`path-part`</a>, and
          |redirect count| is 0, then:

          1.  Let |exact match| be `false` if the final character of
              |expression|'s <a grammar>`path-part`</a> is the U+002F SOLIDUS
              character (`/`), and `true` otherwise.

          2.  Let |path list| be the result of
              <a lt="strictly split a string">strictly splitting</a>
              |expression|'s <a grammar>`path-part`</a> on the U+002F SOLIDUS
              character (`/`).

          3.  If |path list| has more items than |url|'s {{URL/path}}, return
              "`Does Not Match`".

          4.  If |exact match| is `true`, and |path list| does not have the same
              number of items as |url|'s {{URL/path}}, return "`Does Not
              Match`".

          5.  For each |expression piece| in |path list|:

              1.  Let |url piece| be the next item in |url|'s {{URL/path}}.

              2.  <a>Percent decode</a> |expression piece|.

              3.  <a>Percent decode</a> |url piece|.

              4.  If |expression piece| is not an <a>ASCII case-insensitive
                  match</a> for |url piece|, return "`Does Not Match`".

      10. Return "`Matches`".

  4.  If |expression| is an <a>ASCII case-insensitive match</a> for "`'self'`",
      and |origin| is the same as |url|'s {{URL/origin}}, return "`Matches`".

  5.  Return "`Does Not Match`".

  <h5 id="effective-directive-for-a-request">
    Get the effective directive for <var>request</var>
  </h5>

  Each <a>fetch directive</a> controls a specific type of <a>request</a>. Given
  a <a>request</a> (<var>request</var>), the following algorithm returns either
  `null` or the <a for="directive">name</a> of the request's
  <dfn for="request">effective directive</dfn>:

  1.  Switch on <var>request</var>'s <a for="request">type</a>, and execute
      the associated steps:

      : ""
      ::
        1.  If the <var>request</var>'s <a for="request">initiator</a> is
            "`fetch`", return `connect-src`.
        2.  If the <var>request</var>'s <a for="request">initiator</a> is
            "`manifest`", return `manifest-src`.
        3.  If the <var>request</var>'s <a for="request">destination</a> is
            "`subresource`", return `connect-src`.
        4.  If the <var>request</var>'s <a for="request">destination</a> is
            "`unknown`", return `object-src`.
        5.  If the <var>request</var>'s <a for="request">destination</a> is
            "`document`" <em>and</em> the <var>request</var>'s
            <a for="request">target browsing context</a> is a <a>nested browsing
            context</a>, return `child-src`.

      : "`audio`"
      : "`track`"
      : "`video`"
      ::
        1.  Return `media-src`.

      : "`font`"
      ::
        1.  Return `font-src`.

      : "`image`"
      ::
        1.  Return `image-src`.

      : "`style`"
      ::
        1.  Return `style-src`.

      : "`script`"
      ::
        1.  Switch on <var>request</var>'s <a for="request">destination</a>, and
            execute the associated steps:

            : "`subresource`"
            ::
              1.  Return `script-src`.

            : "`serviceworker`"
            : "`sharedworker`"
            : "`worker`"
            ::
              1.  Return `child-src`.

  2.  Return `null`.

  <h5 id="effective-source-list-for-request">
    Get the effective source list for |request| and |policy|
  </h5>

  If the <a for="request">effective directive</a> for a <a>request</a> is not
  present in a <a>policy</a>, <a>fetch directives</a> will fall back to using
  the value of <a>`default-src`</a>, if present. The <dfn>effective source
  list</dfn> for a <a>request</a> (|request|) and <a>policy</a>
  (|policy|) is therefore determined by the following algorithm:

  1.  Let |effective| be the result of executing
      [[#effective-directive-for-a-request]] on |request|.

  2.  If |effective| is `null`, return `null`.

  3.  If a <a>directive</a> whose <a for="directive">name</a> is
      |effective| is present in |policy|'s
      <a for="policy">directive set</a>, return that <a>directive</a>'s
      <a for="directive">value</a>.

  4.  If a <a>directive</a> whose <a for="directive">name</a> is
      `default-src` is present in |policy|'s <a for="policy">directive
      set</a>, return that <a>directive</a>'s <a for="directive">value</a>.

  5.  Return `null`.


  <h4 id="fetch-directive-matching-nodes">Node Matching Algorithms</h4>

  <h5 id="match-node-to-policy">
    Does |node| match |policy|?
  </h5>

  Given a {{Node}} (|node|) and a <a>policy</a> (|policy|), this algorithm
  returns "`Matches`" or "`Does Not Match`".

  1.  Let |directive name| be `null`.

  2.  If |node| is a <{script}> element, set |directive name| to "`script-src`".

  3.  If |node| is a <{style}> element, set |directive name| to "`style-src`".

  4.  If |directive name| is `null`, return "`Matches`".

  5.  Let |source list| be `null`.

  6.  If a <a>directive</a> whose <a for="directive">name</a> is |directive
      name| is present in |policy|'s <a for="policy">directive set</a>, set
      |source list| to that <a>directive</a>'s  <a for="directive">value</a>.

  7.  If |source list| is `null`, and a <a>directive</a> whose
      <a for="directive">name</a> is "`default-src`" is present in |policy|'s
      <a for="policy">directive set</a>, set |source list| to that
      <a>directive</a>'s <a for="directive">value</a>.

  8.  Return the result of executing [[#match-node-to-source-list]] on |node|
      and |source list|.

  <h5 id="match-node-to-source-list">
    Does |node| match source |list|?
  </h5>

  Given a {{Node}} (|node|) and a <a>source list</a> (|list|),
  this algorithm returns "`Matches`" or "`Does Not Match`".

  1.  If |node| is a <{script}> element, and has a <{script/src}> attribute,
      then return "`Matches`".

  2.  Let |contains nonce or hash| be `false`.

  3.  Let |content| be <a>the script block's source</a> if |node| is a
      <{script}> element, or the value of |node|'s {{Node/textContent}}
      IDL attribute for any other element.

  4.  For each |expression| in |list|:

      1.  If |expression| matches the <a grammar>`nonce-source`</a> or
          <a grammar>`hash-source`</a> grammar, set |contains nonce or hash|
          to `true`.

  5.  For each |expression| in |list|:

      1.  If |contains nonce or hash| is `false`, and |expression| is a
          <a>case-sensitive</a> match for "`'unsafe-inline'`", return
          "`Matches`".

      2.  If |expression| matches the <a grammar>`nonce-source`</a> grammar,
          and |node| has a <{script/nonce}> attribute whose value is a
          <a>case-sensitive</a> match for |expression|'s
          <a grammar>`base64-value`</a> part, return "`Matches`".

      3.  If |expression| matches the <a grammar>`hash-source`</a> grammar:
          
          1.  Let |algorithm| be `null`.

          2.  If |expression|'s <a grammar>`hash-algorithm`</a> part is an
              <a>ASCII case-insensitive match</a> for "sha256", set |algorithm|
              to <a>SHA-256</a>.

          3.  If |expression|'s <a grammar>`hash-algorithm`</a> part is an
              <a>ASCII case-insensitive match</a> for "sha384", set |algorithm|
              to <a>SHA-384</a>.

          4.  If |expression|'s <a grammar>`hash-algorithm`</a> part is an
              <a>ASCII case-insensitive match</a> for "sha512", set |algorithm|
              to <a>SHA-512</a>.

          5.  Let |actual| be the result of <a>base64 encoding</a> the result of
              applying |algorithm| to |content|.

          6.  If |actual| is a <a>case-sensitive</a> match for |expression|'s
              <a grammar>`base64-value`</a> part, return "`Matches`".

  6.  Return "`Does Not Match`".

  <h3 id="directives-other">
    Grabbag
  </h3>

  <h4 id="directive-base-uri">`base-uri`</h4>

  The <dfn>base-uri</dfn> directive restricts the {{URL}}s which can be used in
  a {{Document}}'s <{base}> element. The syntax for the directive's name and
  value is described by the following ABNF:

  <pre>
    directive-name  = "base-uri"
    directive-value = <a grammar>serialized-source-list</a>
  </pre>

  The following algorithm is called during HTML's <a>set the frozen base url</a>
  algorithm in order to monitor and enforce this directive:

  <h5 id="allow-base-for-document">
    Is |base| allowed for |document|?
  </h5>

  Given a {{URL}} (|base|), and a {{Document}} (|document|), this algorithm
  returns "`Allowed`" if |base| may be used as the value of a <{base}>
  element's <{base/href}> attribute, and "`Blocked`" otherwise:

  1.  For each |policy| in |document|'s <a>global object</a>'s
      <a for="global object">policy list</a>:

      1.  Let |source list| be `null`.

      2.  If a <a>directive</a> whose <a for="directive">name</a> is
          "`base-uri`" is present in |policy|'s <a for="policy">directive
          set</a>, set |source list| to that <a>directive</a>'s
          <a for="directive">value</a>.

      3.  If |source list| is `null`, skip to the next |policy|.

      4.  If the result of executing [[#match-url-to-source-list]] on |base| and
          |source list| is "`Does Not Match`":
          
          1.  <a>Report a violation</a> for |policy|, "`base-uri`", and
              |document|.
          
          2.  If |policy|'s <a for="policy">disposition</a> is "`enforce`",
              return "`Blocked`".

  2.  Return "`Allowed`".

  <h4 id="directive-form-action">`form-action`</h4>
  <h4 id="directive-frame-ancestors">`frame-ancestors`</h4>

  The <dfn>frame-ancestors</dfn> directive restricts the {{URL}}s which can
  embed the resource using <{frame}>, <{iframe}>, <{object}>, <{embed}>, or
  <{applet}> element. Resources can use this directive to avoid many UI
  Redressing [[UISECURITY]] attacks, by avoiding the risk of being embedded into
  potentially hostile contexts.

  The directive's syntax is described by the following ABNF grammar:

  <pre dfn-type="grammar" link-type="grammar">
    directive-name  = "frame-ancestors"
    directive-value = <a>ancestor-source-list</a>

    <dfn>ancestor-source-list</dfn> = ( <a>ancestor-source</a> *( <a>RWS</a> <a>ancestor-source</a>) ) / "<a>'none'</a>"
    <dfn>ancestor-source</dfn>      = <a>scheme-source</a> / <a>host-source</a>
  </pre>

  ISSUE: TODO: "To enforce the `frame-ancestors` directive...". Will need to be
  called from Fetch, probably right after parsing the policy.

  The `frame-ancestors` directive MUST be ignored when contained in a policy
  declared via a <{meta}> element.

  Note: The `frame-ancestors` directive's syntax is similar to a <a>source
  list</a>, but `frame-ancestors` will not fall back to the `default-src`
  directive's value if one is specified. That is, a policy that declares
  `default-src 'none'` will still allow the resource to be embedded by anyone.

  <h4 id="directive-plugin-types">`plugin-types`</h4>

  <dfn>plugin-types</dfn>

  <h4 id="directive-sandbox">`sandbox`</h4>

  <dfn>sandbox</dfn>

  <h3 id="directives-reporting">
    Reporting Directives
  </h3>

  <h4 id="directive-report-uri">`report-uri`</h4>

  The <dfn>report-uri</dfn> directive is deprecated. Please use the
  <a>reports</a> directive instead.

  <h4 id="directive-report">`reports`</h4>

  The <dfn>reports</dfn> directive defines the endpoint to which violation
  reports are sent. The syntax for the directive's name and
  value is described by the following ABNF:

  <pre>
    directive-name  = "reports"
    directive-value = &lt;URL&gt; ; TODO: Figure out what to use here.
  </pre>

</section>

<!-- Big Text: Algorithms -->
<section>
  <h2 id="algorithms">Algorithms</h2>

  <h3 id="algorithms-matching">Matching Algorithms</h3>


  <h3 id="internal-helpers">Internal Helpers</h3>

  These algorithms are part of the internal processing model of Content Security
  Policy, and are not meant to be called from other specifications.

  <h4 id="get-policies">
    Gather policies for <var>global object</var> and <var>disposition</var>
  </h4>

  Given a <a>global object</a> (<var>global</var>), and a <var>disposition</var>
  of either `enforce` or `monitor` this algorithm returns a list of
  <a>policies</a> which ought to be considered.

  1.  Let <var>policies</var> be an empty list.

  2.  For each <var>policy</var> in <var>global</var>'s
      <a for="global object">policy list</a>:

      1.  If <var>policy</var>'s <a for="policy">disposition</a> is
          <var>disposition</var>, add <var>policy</var> to <var>policies</var>.

  3.  Return <var>policies</var>.
</section>

<!-- Big text: Security -->
<section>
  <h2 id="security-considerations">Security Considerations</h2>

  <h3 id="security-nonces">Nonce Reuse</h3>

  Nonces override the other restrictions present in the directive in which
  they're delivered. It is critical, then, that they remain unguessable, as
  bypassing a resource's policy is otherwise trivial.

  If a server delivers a <a grammar>nonce-source</a> expression as part of a
  <a>policy</a>, the server MUST generate a unique value each time it
  transmits a policy. The generated value SHOULD be at least 128 bits long
  (before encoding), and SHOULD be generated via a cryptographically secure
  random number generator in order to ensure that the value is difficult for
  an attacker to predict.

  Note: Using a nonce to whitelist inline script or style is less secure than
  not using a nonce, as nonces override the restrictions in the directive in
  which they are present. An attacker who can gain access to the nonce can
  execute whatever script they like, whenever they like. That said, nonces
  provide a substantial improvement over <a grammar>'unsafe-inline'</a> when
  layering a content security policy on top of old code. When considering
  <a grammar>'unsafe-inline'</a>, authors are encouraged to consider nonces
  (or hashes) instead.
</section>

<!-- Big text: Authoring -->
<section>
  <h2 id="authoring-considerations">Authoring Considerations</h2>

  <h3 id="multiple-policies">
    The effect of multiple policies
  </h3>

  <em>This section is not normative.</em>

  The above sections note that when multiple policies are present, each must be
  enforced or reported, according to its type. An example will help clarify how
  that ought to work in practice. The behavior of an `XMLHttpRequest`
  might seem unclear given a site that, for whatever reason, delivered the
  following HTTP headers:

  <div class="example">
    <pre>
      Content-Security-Policy: default-src 'self' http://example.com http://example.net;
                               connect-src 'none';
      Content-Security-Policy: connect-src http://example.com/;
                               script-src http://example.com/
    </pre>
  </div>

  Is a connection to example.com allowed or not? The short answer is that the
  connection is not allowed. Enforcing both policies means that a potential
  connection would have to pass through both unscathed. Even though the second
  policy would allow this connection, the first policy contains
  `connect-src 'none'`, so its enforcement blocks the connection. The
  impact is that adding additional policies to the list of policies to enforce
  can <em>only</em> further restrict the capabilities of the protected resource.

  To demonstrate that further, consider a script tag on this page. The first
  policy would lock scripts down to `'self'`, `http://example.com` and
  `http://example.net` via the `default-src` directive. The second, however,
  would only allow script from `http://example.com/`. Script will only load if
  it meets both policy’s criteria: in this case, the only origin that can match
  is `http://example.com`, as both policies allow it.
</section>

<!-- Big Text: IANA -->
<section>
  <h2 id="iana-considerations">IANA Considerations</h2>

  The permanent message header field registry should be updated
  with the following registration: [[!RFC3864]]

  <h3 id="iana-csp">
    Content-Security-Policy
  </h3>

  <dl>
    <dt>Header field name</dt>
    <dd>Content-Security-Policy</dd>

    <dt>Applicable protocol</dt>
    <dd>http</dd>

    <dt>Status</dt>
    <dd>standard</dd>

    <dt>Author/Change controller</dt>
    <dd>W3C</dd>

    <dt>Specification document</dt>
    <dd>This specification (See [[#csp-header]])</dd>
  </dl>
</section>

<section>
  <h2 id="acknowledgements">Acknowledgements</h2>

  Lots of people are awesome.
</section>
