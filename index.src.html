<h1>Content Security Policy Level 3</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec/specs/CSP3/
TR: http://www.w3.org/TR/CSP3/
Shortname: CSP
Level: 3
Editor: Mike West 56384, Google Inc., mkwst@google.com
Group: webappsec
Abstract:
  This document defines a mechanism by which web developers can control the
  resources which a particular page can fetch or execute, as well as a number
  of security-relevant policy decisions.
Indent: 2
!Bug Reports: <a href="https://github.com/w3c/webappsec/issues/new?title=CSP3:%20">via the w3c/webappsec repository on GitHub</a>
Markup Shorthands: css off
</pre>
<pre class="anchors">
spec: ES2015; urlPrefix: http://www.ecma-international.org/ecma-262/6.0/index.html
  type: method
    text: eval(); url: sec-eval-x
spec: FETCH; urlPrefix: https://fetch.spec.whatwg.org/
  type: dfn
    text: main fetch
    text: parse a header value; url: concept-header-parse
    text: request; url: concept-request
    text: response; url: concept-response
  type: attribute
    text: client; for: Request; url: concept-request-client
    text: url; for: Response; url: concept-response-url
    text: header list; for: Response; url: concept-response-header-list
spec: HTML5; urlPrefix: http://www.w3.org/TR/html5/
  type: dfn
    urlPrefix: embedded-content-0.html
      text: an iframe srcdoc document
    urlPrefix: browsers.html
      text: browsing context
      text: create a document object
      text: nested browsing context
      text: nested through; url: browsing-context-nested-through
    urlPrefix: webappapis.html
      text: environment settings object; url: settings-object
      text: incumbent settings object
    urlPrefix: infrastructure.html
      text: ASCII case-insensitive match; url: ascii-case-insensitive
    urlPrefix: document-metadata.html
      text: pragma directives
  type: element
    urlPrefix: document-metadata.html
      text: head; url: the-head-element
      text: meta; url: the-meta-element
      text: link; url: the-link-element
    urlPrefix: scripting-1.html
      text: script; url: the-script-element
  type: element-attr
    urlPrefix: document-metadata.html
      text: content; for: meta; url: attr-meta-content
      text: http-equiv; for: meta; url: attr-meta-http-equiv
  type: interface
    urlPrefix: dom.html
      text: Document
spec: URL; urlPrefix: https://url.spec.whatwg.org/
  type: dfn
    text: local scheme
  type: attribute
    text: scheme; for: URL; url: concept-url-scheme
spec: WORKERS; urlPrefix: http://www.w3.org/TR/workers/
  type: interface
    text: Worker
spec: RFC5234; urlPrefix: https://tools.ietf.org/html/rfc5234
  type: dfn
    text: VCHAR; url: appendix-B.1
    text: WSP; url: appendix-B.1
spec: RFC5890; urlPrefix: https://tools.ietf.org/html/rfc5890
  type: dfn
    text: label; url: section-2.2
spec: RFC6454; urlPrefix: https://tools.ietf.org/html/rfc6454
  type: dfn
    text: globally unique identifier; url: section-2.3
    text: origin; url: section-3.2
    text: the same; url: section-5
spec: RFC7230; urlPrefix: https://tools.ietf.org/html/rfc7230
  type: dfn
    text: OWS; url: section-3.2.3
    text: BWS; url: section-3.2.3
    text: token; url: section-3.2.6
    text: quoted-string; url: section-3.2.6
spec: RFC7231; urlPrefix: https://tools.ietf.org/html/rfc7231
  type: dfn
    url: section-3
      text: resource representation
      text: representation

spec: HTML; text: run a worker; url: https://html.spec.whatwg.org/multipage/workers.html#run-a-worker; type: dfn
</pre>
<pre class="biblio">
{
  "ES2015": {
    "authors": [ "Allen Wirfs-Brock" ],
    "href": "http://www.ecma-international.org/ecma-262/6.0/index.html",
    "title": "ECMAScript® 2015 Language Specification",
    "publisher": "ECMA"
  }
}
</pre>
<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  [INTRODUCTION GOES HERE]

  <h3 id="examples">Examples</h3>

  <h4 id="example-basic">Control Execution</h4>

  <div class="example">
    The developers at <code>https://example.com</code> want to protect
    themselves against cross-site scripting attacks. They can mitigate the
    risk of script injection by ensuring that their trusted CDN is the only
    origin from which script can load and execute. Moreover, they wish to
    ensure that no plugins can execute in their pages' contexts. The
    following policy has that effect:

    <pre>
      Content-Security-Policy: script-src https://cdn.example.com/scripts/; object-src 'none'
    </pre>
  </div>

  <h3 id="goals">Goals</h3>

  Content Security Policy aims to do to a few related things:

  1.  Mitigate the risk of content-injection attacks by giving developers
      fairly granular control over

      *   The resources which can be requested (and subsequently embedded or
          executed) on behalf of a specific {{Document}} or {{Worker}}

      *   The execution of inline script

      *   Dynamic code execution (via {{eval()}} and similar constructs)

      *   The application of inline style

  2.  Mitigate the risk of attacks which require a resource to be embedded
      in a malicious context ("Pixel Perfect", etc) by giving developers
      granular control over the origins which can embed a given resource.

  3.  Provide a policy framework which allows developers to tweak
      security-relevant settings.

  4.  Provide a reporting mechanism which allows developers to detect flaws
      being exploited in the wild.
</section>

<!-- Big Text: Delivery -->
<section>
  <h2 id="delivery">
    Policy Delivery
  </h2>

  This document defines four delivery mechanisms for a resource's policy:

  1.  An HTTP response header (defined in [[#csp-header]] and [[#cspro-header]])
      which declares a policy as a string and applies it to the resource which
      which the header is delivered. The policy syntax is defined in
      [[#syntax]].

  2.  A <{meta}> element (defined in [[#meta-element]]), which declares a policy
      as a string and applies it to the resource in which the <{meta}> element
      is embedded. The policy syntax is defined in [[#syntax]].

  3.  A JavaScript interface (defined in [[#javascript-interface]]).

  4.  Inheritance, which copies a policy into a <a>nested browsing context</a>
      in certain circumstances, as defined in [[#inheritance]].

  Each of these mechanisms can be used to add values to one of three properties
  this specification adds to <a>environment settings objects</a> to store the
  relevant policy data for a resource:

  ISSUE: This monkey-patches HTML. Talk to WHATWG and WICG folks.

  : <dfn export for="environment settings object">
      enforced Content Security Policies
    </dfn>
  :: A list of Content Security Policy objects which are to be enforced for
     the settings object. This property's value is the empty list unless
     otherwise specified.
  : <dfn export for="environment settings object">monitored Content Security Policies</dfn>
  :: A list of Content Security Policy objects which are to be monitored for
     the settings object. This property's value is the empty list unless
     otherwise specified.
  : <dfn export for="environment settings object">
      inherits Content Security Policies
    </dfn>
  :: A boolean value signifying whether or not the policies of an <a>embedding
     <code>Document</code></a> ought to be applied (as described in
     [[#get-policies]]). This property is <code>false</code> unless otherwise
     specified.

  A policy object is <dfn export local-lt="enforcing">enforced</dfn> for an
  <a>environment settings object</a> by inserting it into the object's
  <a>enforced Content Security Policies</a> list. A string is <a>enforced</a>
  by <a>enforcing</a> each result of executing [[#parse-policy-string]] on the
  string.

  A policy object is <dfn export local-lt="monitoring">monitored</dfn> for an
  <a>environment settings object</a> by inserting it into the object's
  <a>monitored Content Security Policies</a> list. A string is <a>monitored</a>
  by <a>monitoring</a> each result of executing [[#parse-policy-string]] on the
  string.

  <h3 id="delivery-declarative">
    Declarative Delivery
  </h3>

  <h4 id="csp-header">
    The <code>Content-Security-Policy</code> HTTP Response Header Field
  </h4>

  The <dfn><code>Content-Security-Policy</code></dfn> HTTP response header field
  is the preferred mechanism for delivering a policy from a server to a client.
  The header's value is represented by the following ABNF [[!RFC5234]]:

  <pre>
    Content-Security-Policy = 1#<a grammar>policy-token</a>
  </pre>

  <div class="example">
    <pre>
      <a>Content-Security-Policy</a>: script-src 'self';
                               reports /csp-reporting-endpoint
    </pre>
  </div>

  A server MAY send different <code>Content-Security-Policy</code> header field
  values with different <a>representations</a> of the same resource.

  A server SHOULD NOT send more than one HTTP response header field named
  "<code>Content-Security-Policy</code>" with a given <a>resource
  representation</a>. The user agent MUST <a>enforce</a> each of the policies
  contained in each such header field as described in [[#policy-application]].

  <h4 id="cspro-header">
    The <code>Content-Security-Policy-Report-Only</code> HTTP Response Header Field
  </h4>

  The <dfn><code>Content-Security-Policy-Report-Only</code></dfn> HTTP response
  header field allows web developers to experiment with policies by monitoring
  (but not enforcing) their effects. The header's value is represented by the
  following ABNF [[!RFC5234]]:

  <pre>
    Content-Security-Policy-Report-Only = 1#<a grammar>policy-token</a>
  </pre>

  This header field allows developers to piece together their security policy in
  an iterative fashion, deploying a report-only policy based on their best
  estimate of how their site behaves, watching for violation reports, and then
  moving to an enforced policy once they've gained confidence in that behavior.

  <div class="example">
    <pre>
      <a>Content-Security-Policy-Report-Only</a>: script-src 'self';
                                           reports /csp-reporting-endpoint
    </pre>
  </div>

  A server MAY send different <code>Content-Security-Policy-Report-Only</code>
  header field values with different <a>representations</a> of the same
  resource.

  A server SHOULD NOT send more than one HTTP response header field named
  "<code>Content-Security-Policy-Report-Only</code>" with a given <a>resource
  representation</a>. The user agent MUST <a>monitor</a> each of the policies
  contained in each such header field as described in [[#policy-application]].

  Note: The <code><a>Content-Security-Policy-Report-Only</a></code> header is
  <strong>not</strong> supported inside a <{meta}> element.

  <h4 id="meta-element">
    The <code>&lt;meta&gt;</code> element
  </h4>

  A {{Document}} may deliver a policy via one or more HTML <{meta}> elements
  whose <{meta/http-equiv}> attributes are an <a>ASCII case-insensitive
  match</a> for the string "<code>Content-Security-Policy</code>". For example:

  <div class="example">
    <pre>
      &lt;meta http-equiv="Content-Security-Policy" content="script-src 'self'"&gt;
    </pre>
  </div>

  Implementation details can be found in [[#apply-via-meta]].

  Authors are <em>strongly encouraged</em> to place <{meta}> elements as early
  in the document as possible, because policies in <{meta}> elements are not
  applied to content which precedes them. In particular, note that resources
  fetched or prefetched using the <code>Link</code> HTTP response header
  field, and resources fetched or prefetched using <{link}> and <{script}>
  elements which precede a <{meta}>-delivered policy will not be blocked.

  Note: A policy specified via a <{meta}> element will be enforced along with
  any other policies active for the protected resource, regardless
  of where they're specified. The general impact of enforcing multiple
  policies is described in [[#multiple-policies]].

  Note: Modifications to the <{meta/content}> attribute of a <{meta}> element
  after the element has been parsed will be ignored.

  Note: The <code><a>Content-Security-Policy-Report-Only</a></code>
  header is <em>not</em> supported inside a <{meta}> element.

   

  <h3 id="javascript-interface">
    Imperative Delivery
  </h3>

  <h3 id="inheritance">
    Inheritance
  </h3>

  <h4 id="inheritance-srcdoc">
    <code>srcdoc</code> IFrames
  </h4>

  Something something <a>an <code>IFrame</code> srcdoc document</a>.

  <h4 id="inheritance-local-schemes">
    Local Schemes
  </h4>

  Something about an <a>origin</a> whose {{URL/scheme}} is a <a>local scheme</a>.
</section>

<!-- Big text: Application -->
<section>
  <h2 id="policy-application">
    Policy Application
  </h2>

  ISSUE: Monkey patches gonna monkey patch.

  <h3 id="apply-to-document">
    Applying policies to a fetched <code>Document</code>
  </h3>

  When <a lt="create a Document object">creating</a> a {{Document}} object
  (<var>document</var>) for a <a>response</a> (<var>response</var>):
    
  1.  If <var>response</var>'s {{Response/url}}'s {{URL/scheme}} is a
      <a>local scheme</a>:

      1.  Set <var>document</var>'s <a>incumbent settings object</a>'s
          <code><a>inherits Content Security Policies</a></code> property to
          <code>true</code>.

  2.  Otherwise:

      1.  Execute [[#apply-policy-from-headers]] on 
          <var>response</var>'s <a attribute>header list</a> and
          <var>document</var>'s <a>incumbent settings object</a>.

  <h3 id="apply-to-srcdoc-document">
    Applying policies to IFrame <code>srcdoc</code> <code>Document</code>s
  </h3>
    

  When <a lt="create a Document object">creating</a> a {{Document}} object
  (<var>document</var>) for <a>an iframe srcdoc document</a>:

  1.  Set <var>document</var>'s <a>incumbent settings object</a>'s
      <code><a>inherits Content Security Policies</a></code> property to
      <code>true</code>.

  <h3 id="apply-to-worker">
    Applying policies to a <code>Worker</code>
  </h3>
  
  When <a lt="run a worker">running a worker</a> <var>worker</var> for
  <a>environment settings object</a> <var>settings</var> successfully
  executes a Fetch in its current step 4:

  1.  If <var>response</var>'s {{Response/url}}'s {{URL/scheme}} is a
      <a>local scheme</a>:

      1.  Set <var>settings</var> <code><a>inherits Content Security
          Policies</a></code> property to <code>true</code>.

  2.  Otherwise:

      1.  Execute [[#apply-policy-from-headers]] on 
          the <a>response</a>'s <a attribute>header list</a> and
          <var>settings</var>.

  Note: This is using the WHATWG's definition of "run a worker", because
  the W3C's version has no concept of environment settings objects.

  <h3 id="apply-via-meta">
    Applying policies via <code>&lt;meta&gt;</code>
  </h3>

  Add the following entry to the <a>pragma directives</a> for the <{meta}>
  element:

  <dl>
    <dt>
      Content security policy
      (<code>http-equiv="content-security-policy"</code>)
    </dt>
    <dd>
      <ol>
        <li>
          If the Document's <{head}> element is not an ancestor of the <{meta}>
          element, abort these steps.
        </li>

        <li>
          If the <{meta}> element lacks a <{meta/content}> attribute, abort
          these steps.
        </li>

        <li>
          Let <var>content</var> be the value of the <{meta/content}> attribute
          of the <{meta}> element.
        </li>

        <li>
          Let <var>policy</var> be the result of executing
          [[#parse-policy-string]] on <var>content</var>.
        </li>

        <li>
          Remove all occurrences of <code>report-uri</code>,
          <code>frame-ancestors</code>, and <code>sandbox</code>
          directives from <var>policy</var>'s directive set.

          Note: User agents are encouraged to issue a warning to developers
          if one or more of these directives are included in a policy
          delivered via <{meta}>.

          ISSUE: Wire all this up once the directives exist and the policy
          object is defined.
        </li>

        <li>
          <a>Enforce</a> <var>policy</var> on the <a>incumbent settings
          object</a>.
      </ol>
    </dd>
  </dl>

  <h3 id="multiple-policies">
    The effect of multiple policies
  </h3>

  <em>This section is not normative.</em>

  The above sections note that when multiple policies are present, each must be
  enforced or reported, according to its type. An example will help clarify how
  that ought to work in practice. The behavior of an <code>XMLHttpRequest</code>
  might seem unclear given a site that, for whatever reason, delivered the
  following HTTP headers:

  <div class="example">
    <pre>
      Content-Security-Policy: default-src 'self' http://example.com http://example.net;
                               connect-src 'none';
      Content-Security-Policy: connect-src http://example.com/;
                               script-src http://example.com/
    </pre>
  </div>

  Is a connection to example.com allowed or not? The short answer is that the
  connection is not allowed. Enforcing both policies means that a potential
  connection would have to pass through both unscathed. Even though the second
  policy would allow this connection, the first policy contains
  <code>connect-src 'none'</code>, so its enforcement blocks the connection. The
  impact is that adding additional policies to the list of policies to enforce
  can <em>only</em> further restrict the capabilities of the protected resource.

  To demonstrate that further, consider a script tag on this page. The first
  policy would lock scripts down to <code>'self'</code>,
  <code>http://example.com</code> and <code>http://example.net</code> via the
  <code>default-src</code> directive. The second, however, would only allow
  script from <code>http://example.com/</code>. Script will only load if it
  meets both policy’s criteria: in this case, the only origin that can match
  is <code>http://example.com</code>, as both policies allow it.
</section>

<!-- Big Text: Syntax -->
<section>
  <h2 id="syntax">
    Policy Syntax
  </h2>

  Something something ABNF [[!RFC5234]].

  Note: The <a>BWS</a>, <a>OWS</a>, <a>token</a>, and <a>quoted-string</a> rules
  are defined in [[RFC7230]].

  <pre>
    <dfn grammar>policy-token</dfn>
  </pre>
</section>

<!-- Big Text: Reporting -->
<section>
  <h2 id="reporting">
    Reporting
  </h2>
</section>

<!-- Big Text: Directives -->
<section>
  <h2 id="directives">
    Directives
  </h2>
</section>

<!-- Big Text: Algorithms -->
<section>
  <h2 id="algorithms">Algorithms</h2>

  <h3 id="fetch-interface">Fetch Interface</h3>

  This specification provides two algorithms which allow Fetch to make decisions
  about whether or not a particular <a>request</a> should be blocked based on
  its {{Request/client}}'s Content Security Policy [[!FETCH]]. The policy check
  occurs twice: once at the top of Fetch, ensuring that outgoing requests
  satisfy the relevant policy; and once at the bottom, ensuring that incoming
  responses match as well (as they could have been modified in interesting ways
  by an intermediate Service Worker). These algorithms can be considered the
  public interface to the Content Security Policy specification:

  <h4 id="should-block-request">
    Should <var>request</var> be blocked by Content Security Policy?
  </h4>

  Given a <a>request</a> (<var>request</var>), this algorithm returns
  <code>Blocked</code> or <code>Allowed</code> based on <var>request</var>'s
  {{Request/client}}'s Content Security Policy.

  Note: [[FETCH]] calls this algorithm as step #3 of its <a>Main Fetch</a>
  algorithm.

  1.  Let <var>client</var> be <var>request</var>'s {{Request/client}}.

  2.  Return <code>Blocked</code>.

  ISSUE: We should probably expand on this definition a bit.

  <h4 id="should-block-response">
    Should <var>response</var> to <var>request</var> be blocked by Content
    Security Policy?
  </h4>

  Given a <a>response</a> (<var>response</var>) and a <a>request</a>
  (<var>request</var>), this algorithm returns <code>Blocked</code> or
  <code>Allowed</code> based on <var>request</var>'s {{Request/client}}'s
  Content Security Policy.

  Note: [[FETCH]] calls this algorithm as step #12 of its <a>Main Fetch</a>
  algorithm.

  1.  Let <var>client</var> be <var>request</var>'s {{Request/client}}.

  2.  Return <code>Blocked</code>.

  ISSUE: We should probably expand on this definition a bit.

  <h3 id="internal-helpers">Internal Helpers</h3>

  These algorithms are part of the internal processing model of Content Security
  Policy, and are not meant to be called from other specifications.

  <h4 id="parse-policy-string">
    Parse <var>string</var> as a Content Security Policy
  </h4>

  Given a string (<var>string</var>), this algorithm will return a list of
  policy objects. In the case of a fatal parse error, this list will be empty.

  <h4 id="get-policies">
    Gather policies for <var>environment settings object</var> and
    <var>disposition</var>
  </h4>

  Given an <a>environment settings object</a> (<var>settings</var>), and a
  <var>disposition</var> of either <code>Enforce</code> or
  <code>Monitor</code> this algorithm returns a list of policy objects which
  ought to be considered.

  In order to properly deal with inheritance, this algorithm will walk through
  a {{Document}} <var>document</var>'s <dfn>embedding documents</dfn>: the
  {{Document}} <a lt="nested through">through which</a> <var>document</var>'s
  <a>browsing context</a> is nested.

  1.  If <var>disposition</var> is <code>Enforce</code>:

  2.  Otherwise, <var>disposition</var> is <code>Monitor</code>:

  <h4 id="apply-policy-from-headers">
    Apply policies from <var>header list</var> to <var>environment settings
    object</var>
  </h4>

  Given a <a>response</a>'s <a attribute>header list</a> (<var>header
  list</var>) and an <a>environment settings object</a> (<var>settings</var>),
  this algorithm extracts the policies which ought to be <a>enforced</a> and
  <a>monitored</a> for the settings object, and does so:

  1.  Let <var>policy to enforce</var> be the result of
      <a lt="parse a header value">parsing</a>
      <a><code>Content-Security-Policy</code></a> in
      <var>header list</var>.

  2.  Let <var>policies</var> be the result of executing
      [[#parse-policy-string]] on <var>policy to enforce</var>.

  3.  <a>Enforce</a> each policy object in <var>policies</var> on
      <var>settings</var>.

  4.  Let <var>policy to monitor</var> be the result of
      <a lt="parse a header value">parsing</a>
      <a><code>Content-Security-Policy-Report-Only</code></a> in
      <var>header list</var>.

  5.  Let <var>policies</var> be the result of executing
      [[#parse-policy-string]] on <var>policy to monitor</var>.

  6.  <a>Monitor</a> each policy object in <var>policies</var> on
      <var>settings</var>.

</section>

<!-- Big Text: IANA -->
<section>
  <h2 id="iana-considerations">IANA Considerations</h2>

  The permanent message header field registry should be updated
  with the following registration: [[!RFC3864]]

  <h3 id="iana-csp">
    Content-Security-Policy
  </h3>

  <dl>
    <dt>Header field name</dt>
    <dd>Content-Security-Policy</dd>

    <dt>Applicable protocol</dt>
    <dd>http</dd>

    <dt>Status</dt>
    <dd>standard</dd>

    <dt>Author/Change controller</dt>
    <dd>W3C</dd>

    <dt>Specification document</dt>
    <dd>This specification (See [[#csp-header]])</dd>
  </dl>

<section>
  <h2 id="acknowledgements">Acknowledgements</h2>

  Lots of people are awesome.
</section>
